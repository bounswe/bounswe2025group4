/// Represents a job posting.
class JobPost {
  final String id;
  final String employerId;
  final String title;
  final String description;
  final String company;
  final String location;
  final bool remote;
  final String ethicalTags;
  final bool inclusiveOpportunity;
  final String? salaryRange;
  final String? contactInformation;
  final String? jobType;
  final DateTime? postedDate;
  final int? minSalary;
  final int? maxSalary;

  JobPost({
    required this.id,
    required this.employerId,
    required this.title,
    required this.description,
    required this.company,
    required this.location,
    required this.remote,
    required this.ethicalTags,
    required this.inclusiveOpportunity,
    this.salaryRange,
    this.contactInformation,
    this.jobType,
    this.postedDate,
    this.minSalary,
    this.maxSalary,
  });

  // Factory constructor for JSON parsing (GET /api/jobs/{id} or GET /api/jobs)
  factory JobPost.fromJson(Map<String, dynamic> json) {
    // Helper to safely parse date
    DateTime? parseDate(String? dateString) {
      if (dateString == null) return null;
      try {
        return DateTime.parse(dateString);
      } catch (e) {
        print("Error parsing date: $dateString, Error: $e");
        return null; // Return null if parsing fails
      }
    }

    return JobPost(
      // Assuming API returns string IDs, convert int if necessary
      id:
          json['id']?.toString() ??
          (throw Exception('Missing required field: id')),
      employerId:
          json['employerId']?.toString() ??
          (throw Exception('Missing required field: employerId')),
      title:
          json['title'] ?? (throw Exception('Missing required field: title')),
      description:
          json['description'] ??
          (throw Exception('Missing required field: description')),
      company:
          json['company'] ??
          (throw Exception('Missing required field: company')),
      location:
          json['location'] ??
          (throw Exception('Missing required field: location')),
      remote:
          json['remote'] ?? (throw Exception('Missing required field: remote')),
      // Assuming ethicalTags is returned as a single string
      ethicalTags: json['ethicalTags'] ?? '', // Default to empty string if null
      inclusiveOpportunity: json['inclusiveOpportunity'] ?? false,
      // Optional fields from GET potentially not in DTO
      salaryRange: json['salaryRange'],
      contactInformation: json['contact'],
      jobType: json['jobType'],
      postedDate: parseDate(
        json['postedDate'],
      ), // Changed from datePosted to postedDate
      minSalary: json['minSalary'] as int?,
      maxSalary: json['maxSalary'] as int?,
    );
  }

  // Method to convert JobPost instance to JSON (for POST /api/jobs)
  // Only includes fields specified in backend API
  // Note: id, employerId, and postedDate are generated by backend
  Map<String, dynamic> toJsonForCreate() {
    return {
      'title': title,
      'description': description,
      'company': company,
      'location': location,
      'remote': remote,
      'ethicalTags': ethicalTags,
      'inclusiveOpportunity': inclusiveOpportunity,
      if (contactInformation != null) 'contact': contactInformation,
      if (minSalary != null) 'minSalary': minSalary,
      if (maxSalary != null) 'maxSalary': maxSalary,
    };
  }

  // Method to convert JobPost instance to JSON (for PUT /api/jobs/{id})
  // Matches backend API specification - id is in path, employerId from auth token
  Map<String, dynamic> toJsonForUpdate() {
    return {
      'title': title,
      'description': description,
      'company': company,
      'location': location,
      'remote': remote,
      'ethicalTags': ethicalTags,
      'inclusiveOpportunity': inclusiveOpportunity,
      if (contactInformation != null) 'contact': contactInformation,
      if (minSalary != null) 'minSalary': minSalary,
      if (maxSalary != null) 'maxSalary': maxSalary,
    };
  }
}
